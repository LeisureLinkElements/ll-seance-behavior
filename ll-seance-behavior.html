<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../ll-firelog-behavior/ll-firelog-behavior.html">

<script>

/**
Enables an element to perform the following actions on any child (target) elements that also have this behavior, have unique HTML ids, may not yet exist in the local DOM, and may have not reached a desired life-cycle state ('ready', 'attached' or 'detached'):

- Set one or more attribute(s) on the target element.
- Set up a callback function that will be called with the target element as an argument.

Examples of target elements:

- an element inside a dom-if or dom-repeat template
- an element dynamically added to the local DOM

Usage:

 1. Add LeisureLinkBehaviors.SeanceBehavior to the parent and child (target) elements.
 1. In the parent element, call the seanceBegin method to set some attributes on the target element, like this:

        this.seanceBegin('theTableId', 'attached', {
          items: dataFromServer,
          title: 'Employees'
        });

        // You can also pass 'ready' or 'detached' as the event.
        // ('created' not supported because the behavior doesn't work that early.)

 1. In the parent element, call the seanceBegin method to set up a callback, like this:

        this.seanceBegin('theTableId', 'attached', null, this.tellMeItAppeared);

        // this.tellMeItAppeared will then be called with the target element.
        // The seance ends at this point.
        // It will not repeat the actions, even if the target element
        // detaches and then reattaches later.

 1. If you change your mind:

        this.seanceEnd('theTableId', 'attached');

@demo demo/index.html
@polymerBehavior
*/

  var LeisureLinkBehaviors = LeisureLinkBehaviors || {};
  LeisureLinkBehaviors.SeanceBehaviorImpl = {

    properties: {

      seanceStates: {
        type: Object,
        value: function () {
          return {
            created: false,
            ready: false,
            attached: false,
            detached: false
          };
        }
      },

      seanceEntityEventPrefix: {
        type: String,
        value: 'seance-entity',
        readOnly: true
      }

    },

    // lifecycle callbacks:

    ready: function () {
      this._seanceStateAttained('ready');
    },

    attached: function () {
      this._seanceStateAttained('attached');
    },

    detached: function () {
      this._seanceStateAttained('detached');
    },

    /**
     * Set attribute(s) on, or call a callback with, a Polymer element that...
     * - also has this SeanceBehavior.
     * - may not yet exist in the local DOM of this element.
     * - may or may not be in the desired life-cycle state ('ready', 'attached' or 'detached')
     *
     * @param entityId {string} The ID of the element ('entity') to communicate with.
     * @param state {string} The state that we are waiting for the entity to be in:
     * - 'ready', 'attached' or 'detached' ('created' is too early for any of this to work)
     * @param attributes {object} (optional) attributes to set on the entity when it attains the desired state.
     * @param callback {function} (optional) method to call in this element when entity attains the desired state.
     * - The callback is called with the entity as the only argument.
     */
    seanceBegin: function (entityId, state, attributes, callback) {

      this._fireLog('seanceBegin(' + entityId + ', ' + state + ')');

      // Validate args:
      if (!_.isString(entityId) || !_.isBoolean(this.seanceStates[state])) {
        return false;
      }

      // Locate the entity:
      var
          _this = this,
          entity = this.$$('#' + entityId);

      if (entity && entity.seanceStates && entity.seanceStates[state]) {
        this._fireLog('Entity already exists and is ' + state);
        // Entity already exists in the desired state. Parents, siblings and children are ecstatic.
        this._seanceCommunicateToEntity(entity, attributes, callback);
      } else {
        // Entity either does not exist or is not in the desired state yet. Relatives are grief-stricken.
        var eventType = this._seanceGetEventType(entityId, state);
        this._fireLog('Entity does not exist or is not ' + state + ' so listen for ' + eventType);
        Polymer.dom(this).parentNode.addEventListener(eventType, function (evt) {
          evt.target.removeEventListener(evt.type);
          _this._seanceCommunicateToEntity(evt.target, attributes, callback);
        });
      }

      return true;
    },

    seanceEnd: function (entityId, state) {
      this.removeEventListener(this._seanceGetEventType(entityId, state));
    },

    _seanceCommunicateToEntity: function (entity, attributes, callback) {
      this._fireLog('_seanceCommunicateToEntity', entity);
      if (!_.isObject(entity)) {
        return false;
      }
      if (_.isObject(attributes)) {
        _.assign(entity, attributes);
      }
      if (_.isFunction(callback)) {
        callback.call(entity);
      }
    },

    _seanceStateAttained: function (state) {
      this.seanceStates[state] = true;
      if (!_.isEmpty(this.id)) {
        var eventType = this._seanceGetEventType(this.id, state);
        this.fire(eventType);
        this._fireLog('Fired ' + eventType);
      }
    },

    _seanceGetEventType: function (entityId, state) {
      return this.seanceEntityEventPrefix + '-' + entityId + '-' + state;
    }

  };
  LeisureLinkBehaviors.SeanceBehavior = [LeisureLinkBehaviors.FireLogBehavior, LeisureLinkBehaviors.SeanceBehaviorImpl]
</script>
