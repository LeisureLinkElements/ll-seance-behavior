<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../ll-firelog-behavior/ll-firelog-behavior.html">

<script type="application/javascript" src="../lodash/lodash.js"></script>

<script>

/**
Enables an element to perform the following actions on any child (target) elements that also have this behavior, have unique HTML ids, may not yet exist in the local DOM, and may have not reached a desired life-cycle state ('ready', 'attached' or 'detached'):

- Set one or more attribute(s) on the target element.
- Set up a callback function that will be called with the target element as an argument.

Examples of target elements:

- an element inside a dom-if or dom-repeat template
- an element dynamically added to the local DOM

Usage:

1. Add LeisureLinkBehaviors.SeanceBehavior to the parent and child (target) elements.
1. The parent element can then call the seanceBegin method to set some attributes on the target element, like this:

        this.seanceBegin('theTableId', 'attached', {
          items: dataFromServer,
          title: 'Employees'
        });

1. The parent element can also call the seanceBegin method to set up a callback, like this. When the target element is attached (if not already), this.tellMeAboutIt is called called with the target element as the only argument.

        this.seanceBegin('theTableId', 'attached', null, this.tellMeAboutIt);

1. NOTE: In both cases (setting attributes or setting a callback), the seance actions are only performed once, even if the target element detaches and reattaches later.

1. If the target element hasn't attached yet, this will prevent those actions from being performed:

        this.seanceEnd('theTableId', 'attached');

NOTE: This behavior includes FireLogBehavior (ll-firelog-behavior), so the API Reference and Show Private API buttons don't work because this behavior is created as SeanceBehaviorImpl.

@demo
@polymerBehavior
*/

  var LeisureLinkBehaviors = LeisureLinkBehaviors || {};
  LeisureLinkBehaviors.SeanceBehaviorImpl = {

    properties: {

      seanceStates: {
        type: Object,
        value: function () {
          return {
            created: false,
            ready: false,
            attached: false,
            detached: false
          };
        }
      },

      _seanceEntityEventPrefix: {
        type: String,
        value: 'seance-entity',
        readOnly: true
      }

    },

    // lifecycle callbacks:

    ready: function () {
      this._seanceStateAttained('ready');
    },

    attached: function () {
      this._seanceStateAttained('attached');
    },

    detached: function () {
      this._seanceStateAttained('detached');
    },

    /**
     * Set attribute(s) on, or call a callback with, a Polymer element that...
     * - also has this SeanceBehavior.
     * - may not yet exist in the local DOM of this element.
     * - may or may not be in the desired life-cycle state ('ready', 'attached' or 'detached')
     * - ('created' event not supported because the behavior won't work yet)
     *
     * Returns true on success.
     *
     * @param entityId {string} The ID of the element ('entity') to communicate with.
     * @param state {string} The state that we are waiting for the entity to be in:
     * - 'ready', 'attached' or 'detached' ('created' is too early for any of this to work)
     * @param attributes {object} (optional) attributes to set on the entity when it attains the desired state.
     * @param callback {function} (optional) method to call in this element when entity attains the desired state.
     * - The callback is called with the entity as the only argument.
     */
    seanceBegin: function (entityId, state, attributes, callback) {

      this._fireLog('Begin seance.');

      // Validate args:
      if (!_.isString(entityId) || !_.isBoolean(this.seanceStates[state])) {
        return false;
      }

      // Locate the entity:
      var
          _this = this,
          entity = this.$$('#' + entityId);

      if (entity && entity.seanceStates && entity.seanceStates[state]) {
        this._fireLog('#' + entityId + ' already exists and is ' + state + ', so perform actions now...');
        // Entity already exists in the desired state. Parents, siblings and children are ecstatic.
        this._seanceCommunicateToEntity(entity, attributes, callback);
      } else {
        // Entity either does not exist or is not in the desired state yet. Relatives are grief-stricken.
        var eventType = this._seanceGetEventType(entityId, state);
        this._fireLog('#' + entityId + ' does not exist or is not ' + state + ', so listen for ' + eventType + '.');
        Polymer.dom(this).parentNode.addEventListener(eventType, function (evt) {
          evt.target.removeEventListener(evt.type);
          _this._seanceCommunicateToEntity(evt.target, attributes, callback);
        });
      }

      return true;
    },

    seanceEnd: function (entityId, state) {
      this._fireLog('End seance.');
      this.removeEventListener(this._seanceGetEventType(entityId, state));
    },

    _seanceCommunicateToEntity: function (entity, attributes, callback) {
      if (!_.isObject(entity)) {
        return false;
      }
      if (_.isObject(attributes)) {
        this._fireLog('Set these attributes on #'+entity.id+':',attributes);
        _.assign(entity, attributes);
      }
      if (_.isFunction(callback)) {
        this._fireLog('Call callback with entity #'+entity.id);
        callback.call(this, entity);
      }
    },

    _seanceStateAttained: function (state) {
      this.seanceStates[state] = true;
      // Update mutually-exclusive states:
      switch (state) {
        case 'attached':
          this.seanceStates.detached = false;
          break;
        case 'detached':
          this.seanceStates.attached = false;
      }
      if (!_.isEmpty(this.id)) {
        var eventType = this._seanceGetEventType(this.id, state);
        this.fire(eventType);
        this._fireLog('Fired '+eventType);
      }
    },

    _seanceGetEventType: function (entityId, state) {
      return this._seanceEntityEventPrefix + '-' + entityId + '-' + state;
    }

  };
  LeisureLinkBehaviors.SeanceBehavior = [LeisureLinkBehaviors.FireLogBehavior, LeisureLinkBehaviors.SeanceBehaviorImpl]
</script>
